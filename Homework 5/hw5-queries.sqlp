/*
Kushagra Agarwal
CSE 414
Homework 5
Fall 2017
Professor: Gang Luo
Date: 11/14/2017
*/

# Creating the datasets and loading the data: 

/*
DROP DATAVERSE hw5 IF EXISTS;
DROP TYPE worldType IF EXISTS;
DROP DATASET world IF EXISTS;

CREATE DATAVERSE hw5;
USE hw5;

CREATE TYPE worldType AS {auto_id: uuid};

CREATE DATASET world(worldType) PRIMARY KEY auto_id AUTOGENERATED;

LOAD DATASET world using localfs(
	("path"="127.0.0.1:///Users/Kush/Desktop/Fall 2017/CSE 414/Homework 5/mondial.adm"),
	("format"="adm"));
*/

# TEST CASE 1: Returning each country one by one.

/*
USE hw5;
SELECT y as country FROM world x, x.mondial.country y;
*/



# Question 1: Retrieve all the names of all cities 
# located in Peru, sorted alphabetically. [30 rows]

USE hw5;
SELECT  u.name as city_name
FROM world x, x.mondial.country y, y.province z, 
     CASE WHEN is_array(z.city) THEN z.city 
     ELSE [z.city] END u 
WHERE y.name = 'Peru';


# Question 2: For each country return its name, 
# its population, and the number of religions, 
# sorted alphabetically by country. [238 rows]

USE hw5;
SELECT  y.name as country_name, y.population, count(r) as religion_num
FROM world x, x.mondial.country y, 
     CASE WHEN is_array(y.religions) THEN y.religions 
     ELSE [y.religions] END r 
GROUP BY y.name, y.population
ORDER BY y.name ASC;


# Question 3: For each religion return the number 
# of countries where it occurs. Order them in 
# decreasing number of countries. [37 rows]

USE hw5;
SELECT  r.`#text` as religion_name, count(y.name) as religion_count
FROM world x, x.mondial.country y, 
     CASE WHEN is_array(y.religions) THEN y.religions 
          WHEN y.religions is missing THEN [] 
          ELSE [y.religions] END r 
GROUP BY religion_name
ORDER BY religion_count DESC;


# Question 4: For each ethnic group, return the number 
# of countries where it occurs, as well as the total 
# population world-wide of that group. (Hint: you 
# need to multiply the ethnicity’s percentage with 
# the country’s population. Use the functions float(x) 
# and/or int(x) to convert a string x to a float or to an int.) [262 rows]

USE hw5;
SELECT e.`#text` as ethnic, 
	sum(float(e.`-percentage`) / 100 * float(y.population)) as enthic_population
	FROM world x, x.mondial.country y,
	CASE WHEN is_array(y.ethnicgroups) THEN y.ethnicgroups
	     WHEN y.ethnicgroups is missing THEN []
	     ELSE [y.ethnicgroups] 
	 	 END e
GROUP BY ethnic;




# Question 5: Compute the list of all mountains, their heights, 
# and the countries where they are located. Here you will join the 
# "mountain" collection with the "country" collection, on the country 
# code. You should return a list consisting of the mountain name, its 
# height, the country code, and country name, in descending order of 
# the height. [272 rows]

USE hw5
SELECT m.name as mountain, int(m.height) as height, y.name as country, 
	   y.`-car_code`
FROM world x, x.mondial.country y, x.mondial.mountain m, split(m.`-country`, " ") id
WHERE y.`-car_code` = id
ORDER BY height DESC;




# Question 6: Compute a list of countries with all their mountains. 
# This is similar to the previous problem, but now you will group the 
# mountains for each country. Your query should return a list where each 
# element consists of the country code, country name, and a list of mountain 
# names and heights. Order the countries by the number of mountains they 
# contain. [238 rows]

USE hw5;
SELECT DISTINCT y.`-car_code`,y.name, z
FROM world x, x.mondial.country y
LET z = (SELECT m.name as mountain, m.height as Height
		FROM world x, x.mondial.country y1, x.mondial.mountain m,
			 split(m.`-country`, " ") id
		WHERE y1.`-car_code` = id AND y = y1
		ORDER BY float(Height) DESC)
ORDER BY array_count(z);



# Question 7: Find all countries bordering two or more seas. Here you 
# need to join the "sea" collection with the "country" collection. 
# For each country in your list, return its code, its name, and its 
# list of bordering seas, in decreasing order of the number of seas. [74 rows]

USE hw5;
SELECT DISTINCT y.name as country, y.`-car_code` as country_code, s as seaOne
FROM world x, x.mondial.country y	
LET s = (SELECT y1.name as seaTwo
		FROM world x, x.mondial.country y1, x.mondial.sea s1,
			      split(s1.`-country`, " ") as border
		WHERE y1.`-car_code` = border AND y = y1)
WHERE array_count(s) >= 2
ORDER BY array_count(s) DESC;




# Question 8: Return all landlocked countries. A country is landlocked 
# if it borders no sea. Order your answers in decreasing order of the 
# country's area. (Note: this should be an easy query to derive from 
# the previous one.) [45 rows]

USE hw5;
SELECT DISTINCT y.name as country, y.`-car_code` as country_code
FROM world x, x.mondial.country y	
LET s = (SELECT s1.name as sea
		FROM world x, x.mondial.country y1, x.mondial.sea s1,
			      split(s1.`-country`, " ") as border
		WHERE y1.`-car_code` = border AND y = y1)
WHERE array_count(s) = 0
ORDER BY float(y.`-area`) DESC;


# Question 9: Find all pairs of countries that share both a 
# mountain and a sea. Your query should return a list of pairs 
# of country names. Avoid including a country with itself, like 
# in (France,France). Also avoid listing both orderings of each 
# pair, e.g., (France,Korea) and (Korea,France) (not a real answer). [7 rows]
# For this query, you should also measure and report the runtime. 
# It may be approximate. (Expect it around 10-30 minutes.)
# Runtime: 1302.588 seconds


USE hw5;
SELECT DISTINCT y1.name as country1, y2.name as country2
FROM world x, x.mondial.country y1, x.mondial.country y2,
	 x.mondial.mountain m, split(m.`-country`, " ") m1, split(m.`-country`, " ") m2, 
	 x.mondial.sea s, split(s.`-country`, " ") s1, split(s.`-country`, " ") s2
WHERE m1 = y1.`-car_code`AND y1.`-car_code` > y2.`-car_code`
AND m2 = y2.`-car_code` AND s1 = y1.`-car_code` AND s2 = y2.`-car_code`;



# Question 10: 

USE hw5index;
CREATE TYPE countryType AS OPEN {
    `-car_code`: string,
	`-area`: string,
	population: string
    };
CREATE DATASET country(countryType)
PRIMARY KEY `-car_code`;
CREATE INDEX countryID ON country(`-car_code`) TYPE BTREE;
LOAD DATASET country using localfs(("path"="127.0.0.1:///home/auser/country.adm"),("format"="adm"));

USE hw5index;
DROP TYPE mountainType IF EXISTS;
CREATE TYPE mountainType AS OPEN {
    id: uuid,
    `-id`: string,
    `-country`: string
    };
CREATE DATASET mountain(mountainType)
PRIMARY KEY id AUTOGENERATED;
CREATE INDEX mountainID ON mountain(`-country`) TYPE KEYWORD;
LOAD DATASET mountain using localfs(("path"="127.0.0.1:///home/auser/mountain.adm"),("format"="adm"));

USE hw5index;
DROP TYPE seaType IF EXISTS;
CREATE TYPE mountainType AS OPEN {
    id: uuid,
    `-id`: string,
    `-country`: string
    };
CREATE DATASET sea(seaType)
PRIMARY KEY id AUTOGENERATED;
CREATE INDEX seaID ON sea(`-country`) TYPE KEYWORD;
LOAD DATASET sea using localfs(("path"="127.0.0.1:///home/auser/sea.adm"),("format"="adm"));





# Question 11: Rewrite the query from problem 9 to work in the new 
# dataverse hw5index. Run it and report the new runtime. [7 rows]
#Runtime: 

USE hw5index;
SELECT DISTINCT y1.name as country1, y2.name as country2
FROM world x, x.mondial.country y1, x.mondial.country y2,
	x.mondial.mountain m, split(m.`-country`, " ") m1, 
	split(m.`-country`, " ") m2, x.mondial.sea s,
	split(s.`-country`, " ") s1, split(s.`-country`, " ") s2
WHERE m1 = y1.`-car_code` AND y1.`-car_code` > y2.`-car_code`
AND m2 = y2.`-car_code` AND s1 = y1.`-car_code` AND s2 = y2.`-car_code`;



# Question 12: Modify the query from problem 11 to return, 
# for each pair of countries, the list of common mountains 
# and the list of common seas. [7 rows]






